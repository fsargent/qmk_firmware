#include QMK_KEYBOARD_H
#include "action_layer.h"
#include "remote_kb.h"
#include "bitc_led.h"

#define _BASE		0
#define _NAV		1
#define _FUNC		2


enum custom_keycodes {
	PROG = SAFE_RANGE,
};

enum td_keycodes {
		TD_ENTER_LAYER
};

// Tap Dance definitions
qk_tap_dance_action_t tap_dance_actions[] = {
		// Tap once for KP_ENTER, twice for _NAV layer
		[TD_ENTER_LAYER] = ACTION_TAP_DANCE_LAYER_TOGGLE(KC_KP_ENTER, 1),
};

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
	// Base layer (numpad)
	[_BASE] = LAYOUT(
									KC_KP_SLASH,	KC_KP_ASTERISK,	KC_KP_MINUS, \
	TO(_NAV),				KC_KP_7,			KC_KP_8,				KC_KP_9,				 \
	KC_KP_PLUS,			KC_KP_4,			KC_KP_5,				KC_KP_6,				 \
	KC_BSPC,				KC_KP_1,			KC_KP_2,				KC_KP_3,			 \
	KC_KP_ENTER,		KC_KP_ENTER,	KC_KP_0,				KC_KP_DOT			 \
	),

[_NAV] = LAYOUT(
							KC_CUT,			KC_COPY,		KC_PASTE,\
	TO(_BASE),	KC_HOME,		KC_UP,			KC_PGUP,\
	KC_LGUI,		A(KC_LEFT),	A(KC_BSPC),	A(KC_RIGHT),\
	KC_LALT,		KC_END,			KC_DOWN,		KC_PGDN,\
	KC_LSFT,		KC_TAB,			KC_SPC,			KC_ENT
	),
	// Function layer (numpad)
	[_FUNC] = LAYOUT(
					 KC_NO, RGB_TOG, KC_NO,
		KC_NO, KC_NO, RGB_MOD, KC_NO,
		KC_NO, KC_NO, RGB_HUI, KC_NO,
		KC_NO, KC_NO, RGB_SAI, KC_NO,
		PROG,	KC_NO, RGB_VAI, TO(_BASE)
	),
};

#ifdef OLED_DRIVER_ENABLE
// oled_rotation_t oled_init_user(oled_rotation_t rotation) { return OLED_ROTATION_270; }

// static void render_logo(void) {
// 	static const char PROGMEM tidbit_oled[] = {
// 		0x00, 0x0e, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
// 		0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x0e, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff,
// 		0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0x1f, 0x1f, 0x1f,
// 		0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x3e, 0x3e, 0x7e, 0xfc, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x00, 0x00,
// 		0x00, 0x00, 0x00, 0x00, 0xf8, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
// 		0x1f, 0x1f, 0x3f, 0x7e, 0xfe, 0xfe, 0xfc, 0xf8, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 		0xfe, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x0e, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
// 		0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1e, 0x00,
// 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
// 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
// 		0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
// 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xc0,
// 		0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0,
// 		0xe0, 0xf0, 0xf0, 0xf8, 0xff, 0xff, 0xbf, 0x1f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 		0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 		0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
// 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
// 		0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
// 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x03,
// 		0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
// 		0x03, 0x03, 0x03, 0x07, 0x07, 0xbf, 0xff, 0xff, 0xff, 0xfe, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00,
// 		0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 		0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x7f, 0xff, 0xff, 0x7f, 0x3f,
// 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff,
// 		0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x7f, 0x7f, 0x7f, 0xff, 0xff, 0xf8, 0xf8, 0xf8,
// 		0xf8, 0xf8, 0xf8, 0x7c, 0x7c, 0x7c, 0x7e, 0x3e, 0x3f, 0x3f, 0x1f, 0x0f, 0x07, 0x01, 0x00, 0x00,
// 		0x00, 0x00, 0x00, 0x00, 0x1f, 0x7f, 0x7f, 0x7f, 0xff, 0xff, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8,
// 		0xf8, 0x7c, 0x7c, 0x7c, 0x7e, 0x3f, 0x3f, 0x1f, 0x1f, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
// 		0x7f, 0xff, 0xff, 0x7f, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 		0x00, 0x3f, 0x7f, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
// };
// 		// Host Keyboard Layer Status
// 		oled_write_raw_P(tidbit_oled, sizeof(tidbit_oled));
// }


static void print_status_narrow(void) {

    // Print current layer
    // enum layers { NUM, NAV, FN };

    switch (get_highest_layer(layer_state)) {
        case 0:
            oled_write_P(PSTR("Num\n"), false);
            break;
        case 1:
            oled_write_P(PSTR("Nav\n"), true);
            break;
         case 2:
            oled_write_P(PSTR("Func\n"), true);
            break;

        default:
            oled_write_ln_P(PSTR("Undef"), false);
    }
    // led_t led_usb_state = host_keyboard_led_state();
    // oled_write_ln_P(PSTR("\n\n\n\n\n\n\n//\nFelix"), led_usb_state.caps_lock);
}

void oled_task_user(void) {
        print_status_narrow();
}
#endif

void matrix_init_user(void) {
	matrix_init_remote_kb();
	register_code(KC_NLCK);
}

void matrix_scan_user(void) {
	matrix_scan_remote_kb();
}

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
	process_record_remote_kb(keycode, record);
	switch(keycode) {
		case PROG:
			if (record->event.pressed) {
				set_bitc_LED(LED_DIM);
				rgblight_disable_noeeprom();
				bootloader_jump(); //jump to bootloader
			}
		break;

		default:
		break;
	}
	return true;
}


// layer_state_t layer_state_set_user(layer_state_t state) {
// 		switch (get_highest_layer(state)) {
// 		case _FUNC:
// 				unregister_code(KC_NLCK);
// 				break;
// 		default: //	for any other layers, or the default layer
// 				register_code(KC_NLCK);
// 				break;
// 		}
// 	return state;
// }


bool encoder_update_user(uint8_t index, bool clockwise) {
	/* With an if statement we can check which encoder was turned. */
	if (index == 0) { /* First encoder */
		if (clockwise) {
			tap_code(KC_PGUP);
		} else {
			tap_code(KC_PGDN);
		}
	} else if (index == 1) { /* Second encoder */
		if (clockwise) {
			tap_code16(A(KC_RIGHT));
		} else {
			tap_code16(A(KC_LEFT));
		}
	}
	return true;
}

void led_set_kb(uint8_t usb_led) {
	if (usb_led & (1<<USB_LED_NUM_LOCK))
		set_bitc_LED(LED_DIM);
	else
		set_bitc_LED(LED_OFF);
}



enum combo_events {
	RST,
    PRT,
	COMBO_LENGTH
};
uint16_t COMBO_LEN = COMBO_LENGTH; // remove the COMBO_COUNT define and use this instead!

const uint16_t PROGMEM reset_combo[] = {KC_KP_ENTER, KC_KP_0, KC_KP_DOT, COMBO_END};
const uint16_t PROGMEM prt_combo[] = {KC_KP_1,KC_KP_2, COMBO_END};


combo_t key_combos[] = {

	[RST] = COMBO_ACTION(reset_combo),
	[PRT] = COMBO_ACTION(prt_combo)

	// Lock computer combo!
};
/* COMBO_ACTION(x) is same as COMBO(x, KC_NO) */

void process_combo_event(uint16_t combo_index, bool pressed) {
	switch(combo_index) {

		case RST:
			if (pressed) {
			    set_bitc_LED(LED_DIM);
				rgblight_disable_noeeprom();
				bootloader_jump(); //jump to bootloader
            }
            break;
        case PRT:
			if (pressed) {
			    SEND_STRING("hello");
            }
            break;
    }
}
